## zip

**zip** - принимает несколько Observable и возвращает новый Observable в виде массива, когда каждый из переданных Observable сгенерирует свое значение. Затем цикл повторяется снова до тех пор, пока переданные Observable генерируют значения.

```js
// ПРИМЕР 1 - zip принимает 2 Observable, каждый из которых выдает одно значение, которые zip объединяет в массив

zip(
  // Выдает 0
  interval(500).pipe(take(1)),
  // Выдает 3
  of(3).pipe(delay(1000)),
).subscribe(vl => console.log(vl));

// РЕЗУЛЬТАТ:
// [0, 3]
```

```js
// ПРИМЕР 2 - zip принимает 3 Observable, каждый из которых выдает три значения, которые zip объединяет в массив на каждой итерации,
// то-есть - когда каждый из трёх Observable выдал одно значение - zip объединил эти значения в массив - это одна итерация

zip(
  // Выдает значения 0, 1, 2 с интервалом 500мс
  interval(500).pipe(take(3)),
  // Выдает все значения 3, 4, 5 одновременно, с задержкой в 1000мс
  of(3, 4, 5).pipe(delay(1000)),
  // Выдает значения 0, 1, 2 с интервалом 100мс
  interval(100).pipe(take(3))
).subscribe(vl => console.log(vl));

// РЕЗУЛЬТАТ:
// [0, 3, 0]
// [1, 4, 1]
// [2, 5, 2]
```

```js
// ПРИМЕР 3 - zip принимает 2 Observable:
// - первый выдает неограниченное число значений
// - второй выдает только 2 значения
// zip выполнит только 2 итерации, далее второй Observable перестанет выдавать новые значения и цикл метода zip завершится

// Выдает значения 0, 1, 2 ... n с интервалом 1000мс
const source = interval(1000);
// когда завершится один из Observable - завершится цикл метода zip
zip(
  source, 
  source.pipe(take(2))
).subscribe(val => console.log(val));

// РЕЗУЛЬТАТ:
// [0, 0]
// [1, 1]
```